"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var user_record_1 = require("./user-record");
var token_generator_1 = require("./token-generator");
var auth_api_request_1 = require("./auth-api-request");
var error_1 = require("../utils/error");
var utils = require("../utils/index");
var validator = require("../utils/validator");
var token_verifier_1 = require("./token-verifier");

var AuthInternals = (function () {
    function AuthInternals() {
    }
    AuthInternals.prototype.delete = function () {
        return Promise.resolve(undefined);
    };
    return AuthInternals;
}());

var Auth = (function () {

    function Auth(app) {
        this.INTERNAL = new AuthInternals();
        if (typeof app !== 'object' || app === null || !('options' in app)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');
        }
        this.app_ = app;
        this.tokenGenerator = new token_generator_1.FirebaseTokenGenerator(token_generator_1.cryptoSignerFromApp(app));
        var projectId = utils.getProjectId(app);
        this.sessionCookieVerifier = token_verifier_1.createSessionCookieVerifier(projectId);
        this.idTokenVerifier = token_verifier_1.createIdTokenVerifier(projectId);
        this.authRequestHandler = new auth_api_request_1.FirebaseAuthRequestHandler(app);
    }
    Object.defineProperty(Auth.prototype, "app", {
        get: function () {
            return this.app_;
        },
        enumerable: true,
        configurable: true
    });

    Auth.prototype.createCustomToken = function (uid, developerClaims) {
        return this.tokenGenerator.createCustomToken(uid, developerClaims);
    };

    Auth.prototype.verifyIdToken = function (idToken, checkRevoked) {
        var _this = this;
        if (checkRevoked === void 0) { checkRevoked = false; }
        return this.idTokenVerifier.verifyJWT(idToken)
            .then(function (decodedIdToken) {
                if (!checkRevoked) {
                    return decodedIdToken;
                }
                return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);
            });
    };

    Auth.prototype.getUser = function (uid) {
        return this.authRequestHandler.getAccountInfoByUid(uid)
            .then(function (response) {
                return new user_record_1.UserRecord(response.users[0]);
            });
    };

    Auth.prototype.getUserByEmail = function (email) {
        return this.authRequestHandler.getAccountInfoByEmail(email)
            .then(function (response) {
                return new user_record_1.UserRecord(response.users[0]);
            });
    };

    Auth.prototype.getUserByPhoneNumber = function (phoneNumber) {
        return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber)
            .then(function (response) {
                return new user_record_1.UserRecord(response.users[0]);
            });
    };

    Auth.prototype.listUsers = function (maxResults, pageToken) {
        return this.authRequestHandler.downloadAccount(maxResults, pageToken)
            .then(function (response) {
                var users = [];
                response.users.forEach(function (userResponse) {
                    users.push(new user_record_1.UserRecord(userResponse));
                });
                var result = {
                    users: users,
                    pageToken: response.nextPageToken,
                };
                if (typeof result.pageToken === 'undefined') {
                    delete result.pageToken;
                }
                return result;
            });
    };

    Auth.prototype.createUser = function (properties) {
        var _this = this;
        return this.authRequestHandler.createNewAccount(properties)
            .then(function (uid) {
                // Return the corresponding user record.
                return _this.getUser(uid);
            })
            .catch(function (error) {
                if (error.code === 'auth/user-not-found') {
                    // Something must have happened after creating the user and then retrieving it.
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');
                }
                throw error;
            });
    };

    Auth.prototype.deleteUser = function (uid) {
        return this.authRequestHandler.deleteAccount(uid)
            .then(function (response) {
                // Return nothing on success.
            });
    };

    Auth.prototype.updateUser = function (uid, properties) {
        var _this = this;
        return this.authRequestHandler.updateExistingAccount(uid, properties)
            .then(function (existingUid) {
                return _this.getUser(existingUid);
            });
    };

    Auth.prototype.setCustomUserClaims = function (uid, customUserClaims) {
        return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims)
            .then(function (existingUid) {
                // Return nothing on success.
            });
    };

    Auth.prototype.revokeRefreshTokens = function (uid) {
        return this.authRequestHandler.revokeRefreshTokens(uid)
            .then(function (existingUid) {
                // Return nothing on success.
            });
    };

    Auth.prototype.importUsers = function (users, options) {
        return this.authRequestHandler.uploadAccount(users, options);
    };

    Auth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {
        // Return rejected promise if expiresIn is not available.
        if (!validator.isNonNullObject(sessionCookieOptions) ||
            !validator.isNumber(sessionCookieOptions.expiresIn)) {
            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));
        }
        return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);
    };

    Auth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {
        var _this = this;
        if (checkRevoked === void 0) { checkRevoked = false; }
        return this.sessionCookieVerifier.verifyJWT(sessionCookie)
            .then(function (decodedIdToken) {
                // Whether to check if the token was revoked.
                if (!checkRevoked) {
                    return decodedIdToken;
                }
                return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);
            });
    };

    Auth.prototype.verifyDecodedJWTNotRevoked = function (decodedIdToken, revocationErrorInfo) {
        // Get tokens valid after time for the corresponding user.
        return this.getUser(decodedIdToken.sub)
            .then(function (user) {
                // If no tokens valid after time available, token is not revoked.
                if (user.tokensValidAfterTime) {
                    // Get the ID token authentication time and convert to milliseconds UTC.
                    var authTimeUtc = decodedIdToken.auth_time * 1000;
                    // Get user tokens valid after time in milliseconds UTC.
                    var validSinceUtc = new Date(user.tokensValidAfterTime).getTime();
                    // Check if authentication time is older than valid since time.
                    if (authTimeUtc < validSinceUtc) {
                        throw new error_1.FirebaseAuthError(revocationErrorInfo);
                    }
                }
                // All checks above passed. Return the decoded token.
                return decodedIdToken;
            });
    };
    return Auth;
}());
exports.Auth = Auth;
